1.考虑静态工厂方法替代构造器
优势，1）有名称，2）不必每次调用都创建一个新对象，3）它们可以返回原返回类型的任何子类型，java.util.EnumSet没有公有构造器，服务提供者框架
4）在创建参数化类型实例的时候，它使代码变得更简洁
缺点，1)类如果不含公有的或者受保护的构造器，不能被子类化,2)它与其他的静态方法实际上没有任何区别，valueOf,of,getInstance
2.遇到多个构造器参数考虑用构建器
重叠构造器模式，参数多难以阅读使用，javabeans模式，对象可能处于不一致状态，
builder模式，内有静态构建器，设置属性返回对象实例，build方法。
不足，十分注重性能的情况下，可能成问题，比重叠模式参数冗长，只有在很多参数，特别还有很多参数是可选时使用。
3.用私有构造器或者枚举类型强化Singleton属性
单例模式 public static final T instance = new T(); private T(){}
利用其中一个方法实现的Singleton类是可序列化的，implements serializable,实例域舜时transient，readResolve()方法，防止反序列化创建一个新的对象。
单元素枚举类型，无偿提供序列化机制，绝对防止多次实例化，即时面对复杂的序列化和反射攻击。
4.通过私有构造器强化不可实例化的能力
5.避免创建不必要的对象
赋值常量可放到静态初始块中，map.keySet()实现由同一个map实例支撑的volatile，当心自动装箱拆箱。
6.消除过期的对象引用
内存泄漏三个常见来源，1）只要是类自己管理内存，需警惕内存泄漏，2）缓存，考虑用weakhashmap，3）监听器和其他回调
7.避免使用终结方法
终结方法，缺点1）行为不稳定2）可移植性问题3）性能损失。
合理使用场景，1)当对象所有者忘记执行显示终止方法，终结方法可当保护伞 2)通过本地方法与本地对象交互时
8.覆盖equals时请遵守通用约定
java.sql.Timestamp对java.util.Date进行了扩展 ，equals比较不能同时使用Date和Timestamp，java.net.URL违反一致性。
高质量equals方法诀窍，1）使用==检查参数是否为这个对象的引用，2）使用instanceof操作符检查“参数是否为正确的类型”，3）把参数转成正确的类型，4）依次比较该类中的关键域的值是否相等，5）测试是否是对称的，传递的，一致的。
9.覆盖equals时总要覆盖hashcode
编写hashcode,相等的实例是否都具有相等的散列码，编写hashcode,使用17,31素数。
10.始终要覆盖toString
11.谨慎的覆盖clone
clone架构与引用可变对象的final域的正常用法不相兼容的，当心深度递归拷贝链表发送栈溢出，用迭代替代递归。数组clone。
12.考虑实现Comparable接口
依赖比较关系的类有TreeSet,TreeMap,Collections,Arrays.  BigDecimal的CompareTo和Equals方法比较结果不相等。一个顺序比较一个同等性比较。
13.使类和成员的可访问性最小化
包级私有的，缺省访问级别，实例域不能公有的。
14.在公有类中使用访问方法而非公有域
15.使可变性最小
使类成为不可变，五条原则，1）不提供修改对象状态的方法2）保证类不会被扩展3）使所有域都是final的4）使所有域都是私有的5）确保对任何可变组件的互斥访问。
优点，不可变对象比较简单，本质上线程安全的，它们不要求同步，可被自由分享，不要进行保护性拷贝，不仅可以共享不可变对象，甚至可以共享它们的内部信息。不可变对象为其他对象提供了大量的构件。
缺点，对于每个不同的值都需要一个单独的对象，在特性情况下存在潜在性能问题。如上百万位的BigInteger。
对于复制多阶段操作，可提供包级私有的可变配套类，或者公有的可变配套类，如string和stringbuilder,bigInteger和bitSet。
没有信服的理由，每个域都应该是final的,TimerTask
16.复合优先于继承
17.要么为继承而设计，并提供文档说明，要么就禁止继承
为了继承而设计的类，唯一的测试方式就是编写子类，构造器决不能调用可被覆盖的方法，如果可继承类实现了Cloneable或Serializable，无论clone, readObject都不可调用可覆盖方法，readResolve,writeReplacce必须成为受保护的方法。
要禁止子类化，类声明为final，或类构造器是私有的或者包级私有，增加公有静态构造器替代构造器。
18.接口优于抽象类
现有的类可以很容易被更新，以实现新的接口。
接口是定义mixin（混合类型）的理想选择。
接口允许我们构造非层次结构的类型框架。
包装类（wrapper class）模式，接口使得安全地增强类的功能成为可能。
通过对你导出的每个重要接口都提供一个抽象的骨架实现（skeletal implementation）类，把这个抽象类的优点结合起来。
抽象类的演变比接口的演变要容易的多。
接口一旦被公开发行，并且已被广泛实现，再想改变这个接口几乎是不可能的。
19.接口只用于定义类型
常量接口是对接口的不良使用，实现常量接口，会导致把实现细节导出到API中。
20.类层次优于标签类
21.用函数对象表示策略
22.优先考虑静态成员类
接口可以定义内部接口，如map.entry
instanceof包含判断null检查
私有静态成员类常见用法代表外围类代表对象的组件
静态成员类和非静态成员类选择非常重要
静态成员类可以独立于外围类存在，非静态成员类不行
非静态成员类的常见用法定义一个适配器，如Map的KeySet类，返回视图集合
匿名类的常见用法
1）动态的创建函数对象，Arrays.sort,匿名的Comparator<? super T>实例
2）创建过程对象，Runnable,Thread,TimerTask
3) 静态工厂方法的内部
如果成员类的每个实例需要指向外围实例的引用，则用非静态类，否则做成静态
假设这个嵌套类属于一个方法的内部，只需一个地方创建实例，并有一个预置的类型说明这个类的特征，用匿名类，否则局部类
23.请不要在新代码中使用原生态类型
如使用List这样的原生态类型，就会失掉类型安全性，但是如果使用像List<Object>这样的参数化类型，则不会
原生态类型Set<E>的一种安全替代方法，无限制的通配符类型Set<?>
原则例外，源于泛型信息可在运行时被擦除，在类文字中和instanceof关键字中，必须使用原生态类型
24.消除非受检警告
如果无法消除警告，同时可证明引起警告的代码是类型安全的，请用@SuppressWarnings注解来禁止警告。推荐使用在局部变量或方法中，需加注释说明原因。
25.列表优先于数组
数组和泛型区别，1）数组是协变得，泛型是不可变得，
2）数组是具体化的，在运行时知道元素类型约束，泛型是被擦除的，在编译时强化类型信息，并在运行时丢弃它们的元素类型信息。
数组和泛型不好的混合使用，需用列表替代数组。
26.优先考虑泛型
实际上并不总能在泛型中使用列表。为了提高性能，列表不是Java提供的基本实现，如ArrayList就需要在数组上实现，而某些类，如HashMap为了提高性能，也在数组上实现
27.优先考虑泛型方法
泛型方法包含类型参数，位于方法修饰符和返回类型之间。
泛型方法，可类型推导，无需指明类型参数的值，编译器通过检查方法参数的类型来计算类型参数的值。
而调用泛型构造器必须指定类型参数，可用泛型静态工厂方法替代。 public static <K,V> HashMap<K,V> newHashMap(){}
泛型单例工厂模式，创建不可变又适合许多不同类型的对象。
28.利用有限的通配符来提升API的灵活性
为了获得最大限度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符类型。PSCS，producer-extends,consumer-super
如果类型参数只在方法声明中出现一次，就可以用通配符(?)取代。comparable,comparator是消费者。
29.优先考虑类型安全的异构容器
注意局限性，如恶意客户端使用原生态形式使用Class对象，可使用type.cast(obj),type.isInstance(obj)
如java.util.Collections  CheckedMap,CheckedSet  
第二局限性在于，不能用不可具体化的类型，如List<String>,List<Integer>类型擦除，都是List.class，可使用String,String[]，注意class.asSubclass(class)
30.用enum代替int常量
int枚举模式和string枚举模式，存在类型安全性和使用方便性不足，int值发生变化客户端必须重新编译，将int枚举常量翻译成可打印的字符串很难。
java的枚举本质上是int值，通过公有的静态final域为每个枚举常量导出实例的类，枚举类型是真正的final，是实例受控的。它们是单例的泛型化，本质上是单元素的枚举。可添加方法和域。
为了将数据与枚举常量关联起来，得声明实例域，并编写一个带有数据并将数据保存在域中的构造器。
将不同的行为与每个枚举常量关联起来，在枚举类型中声明抽象方法，并在特定常量的类主体中，用具体方法覆盖抽象方法。
枚举策略解决多个枚举常量同时共享相同的行为。
31.用实例域代替序数
永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中。
32.用EnumSet代替位域
EnumSet缺点，无法创建不可变的EnumSet,可用collections.unmodifiableSet将EnumSet封装起来
33.用EnumMap代替序数索引
EnumMap内部使用枚举索引ordinal()访问桶数组，避免使用Enum.ordinal()来索引数组，而要使用EnumMap。
34.用接口模拟可伸缩的枚举
虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础枚举类型，对它进行模拟。
35.注解优于命名模式
命名模式缺点，1）文字拼写错误会导致失败，但是没有任何提示2）无法确保它们只用于相应的程序元素上3）没有提供将参数值与程序元素关联的好方法
36.坚持使用Override注解
在你想要覆盖超类声明的每个方法声明中使用Override注解
37.用标记接口定义类型
如Java.io.Serializable是标记接口。
标记接口定义的类型是由被标记类的实例实现的，标记注解则没有定义这样的类型。
标记接口允许你在编译时捕捉到标记注解下要到运行时才能捕捉到的错误。另一优点是可以被更加精确地进行锁定。
标记注解优点，1）它可以通过默认的方式添加一个或者多个注解类型元素2）它是更大的注解机制的一部分。
38.检查参数的有效性
对于公有的方法，要用Javadoc的@throws标签，在文档中说明违反参数值限制时会抛出的异常。
非公有的方法应该使用断言（Assertion）来检查参数。
39.必要时进行保护性拷贝
假设类的客户端会尽其所能来破坏这个类的约束条件，必须保护性的设计程序。
保护性拷贝是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是针对原始对象。
对于参数类型可以被不可信任方子类化的参数，请不要使用clone方法进行保护性拷贝。new一个对象或创建不可变视图，如collections.unmodifiableCollection();
40.谨慎设计方法签名
谨慎地选择方法的名称，不要过于追求提供便利的方法，避免过长的参数，方式1）方法分解成多个方法2）创建辅助类3）从对象构建到方法调用都采用builder模式
对于参数类型，要优先使用接口而不是类，对于boolean参数，要优先使用两个元素的枚举类型。
41.慎用重载
重载方法的选择是静态的，覆盖方法选择是动态的
安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法。当传递相同参数时，所有重载方法的行为必须一致。
String.contentEquals(CharSequence cs)正面,  string.valusOf(char[]),string.valueOf(Object)为反例。
42.慎用可变参数
可变参数的机制通过先创建一个数组，数组的大小为在调用位置所传递的参数数量，然后将参数值传到数组中，最后将数组传递给方法。
在重视性能的情况下，使用可变参数机制要小心，因为可变参数方法的每次调用都会导致进行一次数组分配和初始化，可考虑通过重载化解。
如public void foo() {int a1, int a2, int a3, int... rest}
43.返回零长度的数组或者集合，而不是null
返回类型为数组或集合的方法没理由返回null,而不是返回一个零长度的数组或集合。
44.为所有导出的API元素编写文档注释
45.将局部变量的作用域最小化
46.foreach循环优于传统的for循环
为实现foreach循环，需实现interface Iterable<E>{Iterator<E> iterator();}
47.了解和使用类库
应该熟悉java.lang,java.util,java.util.concurrent,java.io类库.
48.如果需要精确的答案，请避免使用float和double
float,double执行二进制浮点运算，提供较为精确的快速近似计算，不适合用于货币计算。
BigDecimal缺点运算不方便，慢，但提供允许完全控制舍入，int范围不超过9位十进制数字，float范围不超过18位数字，其他使用BigDecimal
49.基本类型优先于装箱基本类型
50.如果其他类型更适合，则尽量避免使用字符串
51.当心字符串连接的性能
52.通过接口引用对象
如果有合适的接口类型存在，那么对于参数，返回值，变量和域来说，就都应该使用接口类型进行声明。
53.接口优于反射机制
java.lang.reflect反射,通过运行程序访问关于已经装载的类的信息的能力.
反射机制,允许一个类使用另外一个类,即使当前者被编译的时候后者还根本不存在.
反射付出的代价:1)丧失了编译时类型检查的好处.2)执行反射访问所需要的代码非常笨拙和冗长3)性能损失
如果只是以非常有限的形式使用反射机制，虽然也要付出少许代价，但是可以获得许多好处。以反射创建实例，然后通过它们的接口或者超类，以正常的方式访问这些实例。
54.谨慎地使用本地方法
本地方法一般用C,C++编写，使用本地方法提高性能的做法不值得提倡，本地语言是不安全的，是与平台相关的，难调试。
55.谨慎地进行优化
要努力编写好的程序而不是快的程序，努力避免那些限制性能的设计决策，要考虑API设计决策的性能后果，在每次试图做优化之前和之后，要对性能进行测量。
56.遵守普遍接受的命名惯例
57.只针对异常的情况才使用异常
设计良好的API不应该强迫它的客户端为了正常的控制流而使用异常。
58.对可恢复的情况使用受检异常，对编程错误使用运行时异常
受检的异常，运行时异常和错误，对可恢复的情况，使用受检异常，并往往指明了可恢复的条件，对程序错误，使用运行时异常。
59.避免不必要地使用受检的异常
60.优先使用标准的异常
61.抛出与抽象相对应的异常
更高层的实现应该捕获底层的异常，同时抛出可以按照高层抽象进行解释的异常，叫做异常转译
异常链，它允许推出适当的高层异常，同时又能捕获底层的原因进行失败分析。
62.每个方法抛出的异常都要有文档
63.在细节消息中包含能捕获失败的信息
64.努力使失败保存原子性
collections.sort,输入列表转变为数组，即时排序失败，输入列表保持原样。ConcurrentModificationException，难以保持失败原子性。
65.不要忽略异常
空的catch块会使异常达不到应有的目的，至少catch块也应该包含一条说明，解释为什么忽略这个异常。
66.同步访问共享的可变数据
安全发布对象引用方法，1)保存在静态域中，作为类初始化的一部分2）保存在volatile,final域或者通过正常锁定访问的域中3）放到并发集合中
67.避免过度同步
多用并发集合
68.executor和task优先于线程
executors.newSingleThreadExecutor(),单线程执行
executors.newCachedThreadPool(),适合小程序
executors.newFixedThreadPool(),固定线程数目的线程池
java.util.Timer,使用容易，一个线程，面对长期任务，会影响到定时的准确性，如唯一线程报异常，就会停止执行。
newScheduledThreadPool(),替代Timer，支持多线程，并且能从未受检异常的任务中恢复。
69.并发工具优先于wait和notify
始终应该用wait循环模式来调用wait方法，永远不要在循环之外调用wait方法。
70.线程安全性的文档化
71.慎用延迟初始化
如果出于性能考虑而需要对静态域使用延迟初始化，就使用lazy initialization holder class模式，现代的vm将在初始化该类的时候，同步域的访问。一旦这个类被初始化，VM将修补代码，以便后续对该域的访问不会导致任何测试或者同步
如果出于性能的考虑而需要对实例域使用延迟初始化，就使用双重检查模式。
72.不要依赖于线程调度器
thread.yield的唯一用途是在测试期间人为的增加程序的并发性，在java语言规范中，thread.yield只是将控制权返回给它的调度器。
不要依赖thread.yield或者线程优先级，仅仅对调度器作些暗示。
73.避免使用线程组
74.谨慎地实现serializable接口
序列版本UID(serial version UID)，会受到类名称，它所实现的接口的名称，以及所有公有的和受保护的成员的名称所影响。
实现serializable接口，需保证反序列化实现由构造器建立起来的约束关系，随着版本的发行，相关的测试负担增加了
实现serializable接口不是一个很轻松就可以做出的决定，为继承而设计的类应该尽可能少的去实现serializable接口，Throwable,Component,HttpServlet
内部类不应该实现serializable，内部类的默认序列化形式是定义不清楚的，静态成员类却可以实现serializable
父类提供一个可访问的无参构造器，子类实现serializable接口
75.考虑使用自定义的序列化形式
对象的序列化机制相当于提供了另一种方式创建对象。也可以理解为如果对象支持序列化，相当于对象声明了一个隐藏的构造函数。如果对象的类结构改变了，那么以前的序列化数据进行反序列化可能导致错误。
 默认的序列化将写入对象的“物理内容”。包括对象本身，以及以此对象为根节点，所能访问的所有引用对象。使用默认序列化可能导致的问题有：
1.序列化数据与序列化对象内部引用的对象的API耦合在一起，如果引用对象的API改变，那么反序列化时可能出现错误
2.序列化引用对象将会消耗额外的空间（序列化数据）和时间（序列化过程）
3.在序列化过程中，可能导致内存溢出
因此建议使用自定义序列化，仅写入对象的“逻辑内容”，基本原则包括：
1.总是考虑使用自定义序列化
2.仅在对象的“物理内容”和“逻辑内容”一致时，才使用默认的序列化
3.考虑覆盖readObject()，保证反序列化对象的一致性和安全性，比如保证对象的某些属性不为空
4.使用@serial标记对象可序列化的私有属性的注释，使用@serialData标记对象的私有序列化方法(如writeObject())的注释，以便这些注释能够出现在文档里
5.建议总是在readObject()/writeObject()里调用defaultReadObject()/defaultWriteObject()，以保证对象序列化的一致性
6.对序列化类，总是显式的声明serialVersionUID属性。
7.如果希望仅能读取反序列化全部完成后的对象，那么应使用synchronized修饰writeObject()
8.尽可能考虑使用transient修饰对象属性（如果属性值是随机生成的，或者与JVM实现相关的，那么这些属性应考虑标记为transient）
serialver生成Serial version UID，如果想新版本的类与现有类不兼容，修改序列版本UID，
76.保护性的编写readObject方法
可更改不可变类，通过附加上一个额外的引用，指向对象实例中的一个私有的域，这样危害很大。许多类的安全性依赖于string的不可变性。
当一个对象被反序列化的时候，对于客户端不应该拥有的对象引用，如果那个域包含了这样的对象引用，就必须要做保护性拷贝，这是非常重要的。
保护性拷贝是在有效性检查之前进行的
77.对于实例受控，枚举类型优先于readResolve
如果依赖readResolve进行实例受控制，带有对象引用类型的所有实例域则都必须声明为transient的
将一个可序列化的实例受控的类编写成枚举，就可以绝对保证除了所声明的常量之外，不会有别的实例。
readResolve的可访问性很重要。
78.考虑用序列化代理替代序列化实例
序列化代理模式，为可序列化的类设计一个私有的静态嵌套类，外围类和其序列化代理类都实现serializable接口，将writeReslove方法添加到外围类中，在外围类中添加readObject方法，在代理类中添加readResolve方法，可参考EnumSet.
序列化代理模式，两个局限性1）不能与可以被客户端扩展的类兼容2）增加了序列化和反序列化的开销